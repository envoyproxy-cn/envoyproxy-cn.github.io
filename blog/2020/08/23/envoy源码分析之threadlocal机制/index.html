<!doctype html><html lang=zh class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.74.2"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>Envoy源码分析之ThreadLocal机制 |</title><meta property="og:title" content="Envoy源码分析之ThreadLocal机制"><meta property="og:description" content="Envoy中的`ThreadLocal`机制其实就是我们经常说的线程本地存储简称TLS(Thread Local Storage)，顾名思义通过TLS定义的变量会在每一个线程专有的存储区域存储一份，访问TLS的时候，其实访问的是当前线程占有存储区域中的副本，因此可以使得线程可以无锁的并发访问同一个变量。"><meta property="og:type" content="article"><meta property="og:url" content="/blog/2020/08/23/envoy%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bthreadlocal%E6%9C%BA%E5%88%B6/"><meta property="article:published_time" content="2020-08-23T00:00:00+00:00"><meta property="article:modified_time" content="2021-07-15T14:17:07+08:00"><meta itemprop=name content="Envoy源码分析之ThreadLocal机制"><meta itemprop=description content="Envoy中的`ThreadLocal`机制其实就是我们经常说的线程本地存储简称TLS(Thread Local Storage)，顾名思义通过TLS定义的变量会在每一个线程专有的存储区域存储一份，访问TLS的时候，其实访问的是当前线程占有存储区域中的副本，因此可以使得线程可以无锁的并发访问同一个变量。"><meta itemprop=datePublished content="2020-08-23T00:00:00+00:00"><meta itemprop=dateModified content="2021-07-15T14:17:07+08:00"><meta itemprop=wordCount content="288"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Envoy源码分析之ThreadLocal机制"><meta name=twitter:description content="Envoy中的`ThreadLocal`机制其实就是我们经常说的线程本地存储简称TLS(Thread Local Storage)，顾名思义通过TLS定义的变量会在每一个线程专有的存储区域存储一份，访问TLS的时候，其实访问的是当前线程占有存储区域中的副本，因此可以使得线程可以无锁的并发访问同一个变量。"><link rel=preload href=/scss/main.min.e226c86e583aaf61ca1bcce636aaa0d0bbeebe95c29d67c149aa547ec23c4094.css as=style><link href=/scss/main.min.e226c86e583aaf61ca1bcce636aaa0d0bbeebe95c29d67c149aa547ec23c4094.css rel=stylesheet integrity><script src=/js/jquery-3.5.1.min.js></script><script src=/js/lunr.min.js></script></head><body class="td-page td-blog"><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar"><a class=navbar-brand href=/><span class=navbar-logo><svg width="200" height="269" viewBox="0 0 522 169" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><title>Envoy_Logo_Final_PANTONE-REVERSE</title><desc>Created with Sketch.</desc><defs><polygon id="path-1" points="0 0.449 0 87.94 91.22 87.94 91.22 0.449"/><polygon id="path-3" points="0.695126691 0.484 191.856996 0.484 191.856996 163.037966 0.695126691 163.037966"/></defs><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Envoy_Logo_Final_PANTONE-REVERSE"><path d="M294.535 85.529C294.463 83.366 294.12 81.383 293.507 79.579 292.895 77.777 291.975 76.21 290.75 74.875 289.522 73.541 287.991 72.494 286.152 71.738 284.313 70.981 282.167 70.601 279.716 70.601 277.337 70.601 275.155 71.052 273.172 71.953 271.187 72.857 269.511 74.028 268.141 75.469 266.771 76.912 265.708 78.517 264.95 80.283 264.193 82.051 263.815 83.799 263.815 85.529H294.535zM263.815 93.317C263.815 95.554 264.302 97.591 265.275 99.43 266.249 101.269 267.529 102.837 269.115 104.135 270.7 105.433 272.539 106.443 274.632 107.163 276.723 107.886 278.886 108.245 281.122 108.245 284.151 108.245 286.782 107.543 289.02 106.136 291.253 104.73 293.309 102.874 295.185 100.565L302.54 106.191C297.131 113.186 289.559 116.683 279.824 116.683 275.785 116.683 272.125 115.996 268.845 114.628 265.563 113.259 262.787 111.365 260.515 108.948 258.245 106.533 256.494 103.685 255.269 100.404 254.042 97.122 253.43 93.571 253.43 89.747 253.43 85.926 254.097 82.375 255.432 79.093 256.765 75.813 258.604 72.964 260.948 70.548 263.291 68.132 266.086 66.239 269.332 64.868 272.576 63.499 276.109 62.813 279.933 62.813 284.476 62.813 288.316 63.607 291.453 65.194 294.59 66.78 297.167 68.853 299.187 71.413 301.205 73.974 302.666 76.859 303.568 80.066 304.469 83.276 304.92 86.54 304.92 89.856V93.317H263.815z" id="Fill-1" fill="#fffffe"/><path d="M313.358 64.111H323.093V72.007H323.309C324.534 69.267 326.663 67.05 329.691 65.355 332.72 63.661 336.217 62.813 340.183 62.813 342.635 62.813 344.998 63.192 347.268 63.949 349.54 64.707 351.523 65.879 353.218 67.464 354.912 69.052 356.264 71.088 357.275 73.577 358.284 76.064 358.79 79.004 358.79 82.392V115.385H349.053V85.097C349.053 82.716 348.729 80.68 348.081 78.985 347.431 77.292 346.566 75.921 345.483 74.875 344.403 73.829 343.159 73.073 341.752 72.603 340.346 72.134 338.885 71.899 337.372 71.899 335.351 71.899 333.477 72.224 331.746 72.873S328.502 74.55 327.202 75.956C325.904 77.362 324.894 79.147 324.174 81.31 323.453 83.475 323.093 86.035 323.093 88.991V115.385H313.358V64.111" id="Fill-2" fill="#fffffe"/><polyline id="Fill-3" fill="#fffffe" points="361.925 64.111 373.176 64.111 388.537 103.378 403.248 64.111 413.632 64.111 393.513 115.385 382.804 115.385 361.925 64.111"/><path d="M424.668 89.747C424.668 92.345 425.063 94.742 425.857 96.941 426.65 99.143 427.768 101.016 429.211 102.567 430.652 104.117 432.418 105.344 434.511 106.244 436.602 107.147 438.946 107.596 441.542 107.596 444.138 107.596 446.481 107.147 448.573 106.244 450.664 105.344 452.43 104.117 453.873 102.567 455.315 101.016 456.432 99.143 457.227 96.941 458.02 94.742 458.417 92.345 458.417 89.747 458.417 87.151 458.02 84.755 457.227 82.555 456.432 80.356 455.315 78.481 453.873 76.929 452.43 75.38 450.664 74.155 448.573 73.251 446.481 72.351 444.138 71.899 441.542 71.899 438.946 71.899 436.602 72.351 434.511 73.251 432.418 74.155 430.652 75.38 429.211 76.929 427.768 78.481 426.65 80.356 425.857 82.555 425.063 84.755 424.668 87.151 424.668 89.747zM414.283 89.747C414.283 85.999 414.987 82.501 416.392 79.255 417.798 76.01 419.727 73.163 422.179 70.709 424.63 68.259 427.515 66.329 430.833 64.922 434.149 63.516 437.718 62.813 441.542 62.813 445.363 62.813 448.933 63.516 452.251 64.922 455.567 66.329 458.453 68.259 460.906 70.709 463.356 73.163 465.286 76.01 466.693 79.255 468.098 82.501 468.802 85.999 468.802 89.747 468.802 93.498 468.098 97.014 466.693 100.295 465.286 103.578 463.356 106.425 460.906 108.841 458.453 111.257 455.567 113.167 452.251 114.574 448.933 115.98 445.363 116.683 441.542 116.683 437.718 116.683 434.149 115.98 430.833 114.574 427.515 113.167 424.63 111.257 422.179 108.841 419.727 106.425 417.798 103.578 416.392 100.295 414.987 97.014 414.283 93.498 414.283 89.747z" id="Fill-4" fill="#fffffe"/><path d="M469.557 64.111h11.25L495.99 104.135H496.208L510.771 64.111H521.155L496.817 126.418C495.954 128.653 495.056 130.692 494.123 132.531 493.19 134.368 492.076 135.938 490.785 137.236 489.491 138.534 487.93 139.543 486.097 140.264 484.266 140.984 482.022 141.346 479.365 141.346 477.928 141.346 476.473 141.255 475.002 141.075 473.529 140.895 472.111 140.517 470.747 139.94L471.931 131.07C473.864 131.863 475.799 132.259 477.734 132.259 479.238 132.259 480.51 132.06 481.55 131.665 482.587 131.267 483.483 130.692 484.237 129.933 484.988 129.177 485.615 128.293 486.118 127.283 486.618 126.273 487.12 125.12 487.623 123.822L490.774 115.709 469.557 64.111" id="Fill-5" fill="#fffffe"/><polyline id="Fill-6" fill="#953984" points="56.279 81.853 56.601 95.448 70.917 104.324 70.596 90.72 56.279 81.853"/><g id="Group-10" transform="translate(0.000000, 81.000000)"><mask id="mask-2" fill="#fff"><use xlink:href="#path-1"/></mask><g id="Clip-8"/><path d="M91.22 57.357 90.907 44.042 78.361 36.268C78.175 36.152 78.01 36.016 77.829 35.894L78.146 49.254 91.22 57.357" id="Fill-7" fill="#953984" mask="url(#mask-2)"/><path d="M46.52 75.284 13.788 55.002 12.992 20.964 29.039 14.044 28.717.449 3.107 11.49C1.137 12.347-.047 14.154.001 16.262L.962 57.097C1.01 59.204 2.29 61.267 4.313 62.53L43.567 86.856C45.396 87.987 47.602 88.297 49.462 87.709 49.659 87.647 49.838 87.576 50.017 87.506L74.105 77.122 61.04 69.022 46.52 75.284" id="Fill-9" fill="#953984" mask="url(#mask-2)"/></g><path d="M152.283 81.075C152.223 78.627 150.736 76.202 148.374 74.744L100.716 45.207 99.245 45.842 99.582 60.134 137.32 83.514 138.222 121.754 152.655 130.698 153.442 130.358 152.283 81.075" id="Fill-11" fill="#ac6199"/><g id="Group-15" transform="translate(34.000000, 0.000000)"><mask id="mask-4" fill="#fff"><use xlink:href="#path-3"/></mask><g id="Clip-13"/><path d="M61.206 148.199 16.93 120.759 15.842 74.699 36.014 66.01 35.64 50.146 4.319 63.648C2.022 64.649.637 66.769.697 69.216L1.972 123.211C2.02 125.663 3.514 128.071 5.876 129.53L57.772 161.701C59.91 163.024 62.482 163.383 64.65 162.698 64.872 162.628 65.088 162.546 65.297 162.452L95.953 149.237 80.709 139.791 61.206 148.199" id="Fill-12" fill="#ac6199" mask="url(#mask-4)"/><path d="M118.133 137.748 60.302 101.911 58.88 41.761 115.291 17.448 173.116 53.272 174.538 113.422 118.133 137.748zM185.76 43.255 119.219 2.011C116.764.49 113.838.089 111.335.88 111.089.958 110.848 1.047 110.611 1.148L45.707 29.137C43.078 30.271 41.497 32.686 41.563 35.49L43.195 104.712C43.26 107.516 44.968 110.27 47.664 111.941L114.2 153.172C116.646 154.687 119.573 155.099 122.061 154.313 122.307 154.235 122.56 154.142 122.807 154.036L187.717 126.059C190.346 124.925 191.921 122.498 191.855 119.693L190.23 50.484C190.164 47.68 188.456 44.925 185.76 43.255z" id="Fill-14" fill="#c04589" mask="url(#mask-4)"/></g></g></g></svg></span><span class="text-uppercase font-weight-bold"></span></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/docs/><span>文档</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class="nav-link active" href=/blog/><span class=active>博客</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/docs/community/><span>社区</span></a></li></ul></div><div class="navbar-nav d-none d-lg-block"><input type=search class="form-control td-search-input" placeholder="&#xf002 站内搜索…" aria-label=站内搜索… autocomplete=off></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"><div id=td-sidebar-menu class=td-sidebar__inner><form class="td-sidebar__search d-flex align-items-center"><input type=search class="form-control td-search-input" placeholder="&#xf002 站内搜索…" aria-label=站内搜索… autocomplete=off>
<button class="btn btn-link td-sidebar__toggle d-md-none p-0 ml-3 fas fa-bars" type=button data-toggle=collapse data-target=#td-section-nav aria-controls=td-docs-nav aria-expanded=false aria-label="Toggle section navigation"></button></form><nav class="collapse td-sidebar-nav" id=td-section-nav><ul class="td-sidebar-nav__section pr-md-3"><li class=td-sidebar-nav__section-title><a href=/blog/ class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">博客</a></li><ul><li class="collapse show" id=blog><ul class="td-sidebar-nav__section pr-md-3"><li class=td-sidebar-nav__section-title><a href=/blog/code/ class="align-left pl-0 pr-2 active td-sidebar-link td-sidebar-link__section">源码分析</a></li><ul><li class="collapse show" id=blogcode><a class="td-sidebar-link td-sidebar-link__page" id=m-blog20200823envoye6ba90e7a081e58886e69e90e4b98bdispatchere69cbae588b6 href=/blog/2020/08/23/envoy%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bdispatcher%E6%9C%BA%E5%88%B6/>Envoy源码分析之Dispatcher机制</a>
<a class="td-sidebar-link td-sidebar-link__page active" id=m-blog20200823envoye6ba90e7a081e58886e69e90e4b98bthreadlocale69cbae588b6 href=/blog/2020/08/23/envoy%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bthreadlocal%E6%9C%BA%E5%88%B6/>Envoy源码分析之ThreadLocal机制</a></li></ul></ul><a class="td-sidebar-link td-sidebar-link__page" id=m-blog20200510e5a682e4bd95e4b8ba-envoy-e69e84e5bbbae4b880e4b8aae68ea7e588b6e99da2e69da5e7aea1e79086e99b86e7bea4e7bd91e7bb9ce6b581e9878f href=/blog/2020/05/10/%E5%A6%82%E4%BD%95%E4%B8%BA-envoy-%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%A5%E7%AE%A1%E7%90%86%E9%9B%86%E7%BE%A4%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F/>如何为 Envoy 构建一个控制面来管理集群网络流量</a></li></ul></ul></nav></div></div><div class="d-none d-xl-block col-xl-2 td-toc d-print-none"><div class="td-page-meta ml-2 pb-1 pt-2 mb-0"><a href=https://github.com/envoyproxy-cn/envoyproxy-cn.io/edit/master/content/zh/blog/code/thread_local.md target=_blank><i class="fa fa-edit fa-fw"></i>编辑此页</a>
<a href="https://github.com/envoyproxy-cn/envoyproxy-cn.io/issues/new?title=Envoy%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90%e4%b9%8bThreadLocal%e6%9c%ba%e5%88%b6" target=_blank><i class="fab fa-github fa-fw"></i>提交文档问题</a>
<a href=https://github.com/envoyproxy-cn/envoyproxy-cn.io/issues/new target=_blank><i class="fas fa-tasks fa-fw"></i>提交项目问题</a></div></div><main class="col-12 col-md-9 col-xl-8 pl-md-5 pr-md-4" role=main><a class="btn btn-lg -bg-orange td-rss-button d-none d-lg-block" href=/blog/code/index.xml target=_blank>RSS <i class="fa fa-rss ml-2"></i></a><div class=td-content><h1>Envoy源码分析之ThreadLocal机制</h1><div class=lead>Envoy中的<code>ThreadLocal</code>机制其实就是我们经常说的线程本地存储简称TLS(Thread Local Storage)，顾名思义通过TLS定义的变量会在每一个线程专有的存储区域存储一份，访问TLS的时候，其实访问的是当前线程占有存储区域中的副本，因此可以使得线程可以无锁的并发访问同一个变量。</div><div class="td-byline mb-4"><time datetime=2020-08-23 class=text-muted>2020年8月23日</time></div><h1 id=threadlocal机制>ThreadLocal机制</h1><p>​ Envoy中的<code>ThreadLocal</code>机制其实就是我们经常说的线程本地存储简称TLS(Thread Local Storage)，顾名思义通过TLS定义的变量会在每一个线程专有的存储区域存储一份，访问TLS的时候，其实访问的是当前线程占有存储区域中的副本，因此可以使得线程可以无锁的并发访问同一个变量。Linux上一般有三种方式来定义一个TLS变量。</p><ul><li>gcc对C语言的扩展<code>__thread</code></li><li>pthread库提供的<code>pthread_key_create</code></li><li>C++11的<code>std::thread_local</code>关键字</li></ul><p>​ Envoy的<code>ThreadLocal</code>机制就是在C++11的<code>std::thread_local</code>基础上进行了封装用于实现线程间的数据共享。Envoy因其配置的动态生效而出名，而配置动态生效的基石就是<code>ThreadLocal</code>机制，通过<code>ThreadLocal</code>机制将配置可以无锁的在多个线程之间共享，当配置发生变更的时候，通过主线程将更新后的配置Post到各个线程中，交由各个线程来更新自己的<code>ThreadLocal</code>。</p><h1 id=threadlocalobject>ThreadLocalObject</h1><p>​ Envoy要求所有的<code>ThreadLocal</code>数据对象都要继承<code>ThreadLocalObject</code>，比如下面这个<code>ThreadLocal</code>对象。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>ThreadLocalCachedDate</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>ThreadLocal</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>ThreadLocalObject</span> <span style=color:#000;font-weight:700>{</span>
   <span style=color:#000>ThreadLocalCachedDate</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>const</span> <span style=color:#000>std</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>string</span><span style=color:#ce5c00;font-weight:700>&amp;</span> <span style=color:#000>date_string</span><span style=color:#000;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>:</span> 
   <span style=color:#000>date_string_</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>date_string</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{}</span>
  <span style=color:#204a87;font-weight:700>const</span> <span style=color:#000>std</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>string</span> <span style=color:#000>date_string_</span><span style=color:#000;font-weight:700>;</span>
<span style=color:#000;font-weight:700>};</span>
</code></pre></div><p>​ 但实际上<code>ThreadLocalObject</code>只是一个空的接口类，所以并非我们继承了<code>ThreadLocalObject</code>就是一个TLS了。继承<code>ThreadLocalObject</code>目的是为了可以统一对所有要进行TLS的对象进行管理。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>ThreadLocalObject</span> <span style=color:#000;font-weight:700>{</span>
<span style=color:#204a87;font-weight:700>public</span><span style=color:#ce5c00;font-weight:700>:</span>
  <span style=color:#204a87;font-weight:700>virtual</span> <span style=color:#ce5c00;font-weight:700>~</span><span style=color:#000>ThreadLocalObject</span><span style=color:#000;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>default</span><span style=color:#000;font-weight:700>;</span>
<span style=color:#000;font-weight:700>};</span>
<span style=color:#204a87;font-weight:700>using</span> <span style=color:#000>ThreadLocalObjectSharedPtr</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>std</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>shared_ptr</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>ThreadLocalObject</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#000;font-weight:700>;</span>
</code></pre></div><p>​ Envoy中需要TLS的数据有很多，最重要的当属配置，随着配置的增多，这类数据所占据的内存也会变得很大，如果每一种配置都声明为TLS会导致不少内存浪费。为此Envoy通过<code>ThreadLocalData</code>将所有要进行TLS的对象都管理起来，然后将<code>ThreadLocalData</code>本身设置为TLS，通过TLS中保存的指针来访问对应的数据。这样就可以避免直接在TLS中保存数据而带来内存上的浪费，只需要保存指向数据的指针即可，相关代码如下。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>ThreadLocalData</span> <span style=color:#000;font-weight:700>{</span>
  <span style=color:#8f5902;font-style:italic>// 指向当前线程的Dispatcher对象 
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#000>Event</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>Dispatcher</span><span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>dispatcher_</span><span style=color:#000;font-weight:700>{};</span>
  <span style=color:#8f5902;font-style:italic>// 保存了所有要TLS的数据对象的智能指针，通过智能指针来访问真正的数据对象
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#000>std</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>vector</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>ThreadLocalObjectSharedPtr</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>data_</span><span style=color:#000;font-weight:700>;</span>
<span style=color:#000;font-weight:700>};</span>
</code></pre></div><p><img src=https://ata2-img.oss-cn-zhangjiakou.aliyuncs.com/a4712346b33dc89bc09bb5c41332c5ba.jpg alt=4-2.jpg></p><pre><code>如上图所示，每一个TLS通过指针指向实际的对象，每一个数据对象只在内存中保存一份，避免内存上的浪费，但是这样带来问题就是如何做到线程安全的访问数据对象呢?  当我们要访问数据对象的时候，如果此时正在对数据对象进行更新，这个时候就会存在一个线程安全的问题了。Envoy巧妙的通过在数据对象更新的时候，先构造出一个新的数据对象，然后将TLS中的数据对象指针指向新的数据对象来实现线程安全的访问。本质上和COW(copy-on-write)很类似，但是存在两点区别。
</code></pre><ul><li>COW中是先拷贝原来的对象，然后更改对象，而Envoy在这里是重新构建一个新的数据对象</li><li>COW中无论是读还是写，在更改<code>shared_ptr</code>指向时，都需要加锁，因为<code>shared_ptr</code>本身的读写时非线程安全的，而Envoy不需要加锁。</li></ul><p>​ Envoy中指向数据对象的<code>shared_ptr</code>并非只有一个，而是每一个线程都有一个<code>shared_ptr</code>指向数据对象，更改<code>shared_ptr</code>指向新的数据对象时通过post一个任务到对应线程中，然后在同一个线程使<code>shared_ptr</code>指向新的数据对象，因此并没有多线程操作<code>shared_ptr</code>，所以没有线程安全问题，自然也不用加锁，这是Envoy实现比较巧妙的地方。</p><p><img src=https://ata2-img.oss-cn-zhangjiakou.aliyuncs.com/b1b456618697f8df6c2a0e81bba4a907.jpg alt=4-3.jpg></p><p>​ 如上图所示，T1时刻，Thread1通过TLS对象访问<code>ThreadLocalObjectOld</code>，在T2时刻在main线程发现配置发生了变化，重新构造了一个新的<code>ThreadlocalObjectNew</code>对象，然后通过Thread1的<code>Dispatcher</code>对象post了一个任务到Thread1线程，到了T3时刻这个任务开始执行，将对应的指针指向了 <code>ThreadLocalObjectNew</code>，最后在T4时刻再次访问配置的时候，就已经访问的是最新的配置了。到此为止就完成了一次配置更新，而且整个过程是线程安全的。</p><h1 id=threadlocal>ThreadLocal</h1><p>​ 终于到了分析真正的ThreadLocal对象的时候，它的功能其实很简单，大部分的能力都是依赖<code>Dispatcher</code>、还有上文中提到的<code>SlotImpl</code>、<code>ThreadLocalData</code>等，<code>Instance</code>是它的接口类，它继承了<code>SlotAllocator</code>接口，也包含了上文中分析的<code>allocateSlot</code>方法。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>Instance</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>SlotAllocator</span> <span style=color:#000;font-weight:700>{</span>
<span style=color:#204a87;font-weight:700>public</span><span style=color:#ce5c00;font-weight:700>:</span>
  <span style=color:#8f5902;font-style:italic>// 每启动一个worker线程就需要通过这个方法进行注册
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#204a87;font-weight:700>virtual</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>registerThread</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>Event</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>Dispatcher</span><span style=color:#ce5c00;font-weight:700>&amp;</span> <span style=color:#000>dispatcher</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>bool</span> <span style=color:#000>main_thread</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000>PURE</span><span style=color:#000;font-weight:700>;</span>
  <span style=color:#8f5902;font-style:italic>// 主线程在退出的时候调用，用于标记shutdown状态
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#204a87;font-weight:700>virtual</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>shutdownGlobalThreading</span><span style=color:#000;font-weight:700>()</span> <span style=color:#000>PURE</span><span style=color:#000;font-weight:700>;</span>
  <span style=color:#8f5902;font-style:italic>// 每一个worker线程需要调用这个方法来释放自己的TLS
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#204a87;font-weight:700>virtual</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>shutdownThread</span><span style=color:#000;font-weight:700>()</span> <span style=color:#000>PURE</span><span style=color:#000;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>virtual</span> <span style=color:#000>Event</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>Dispatcher</span><span style=color:#ce5c00;font-weight:700>&amp;</span> <span style=color:#000>dispatcher</span><span style=color:#000;font-weight:700>()</span> <span style=color:#000>PURE</span><span style=color:#000;font-weight:700>;</span>
<span style=color:#000;font-weight:700>};</span>
</code></pre></div><p>​ 对应的实现是<code>InstanceImpl</code>对象，在<code>Instance</code> 的基础上又扩展了一些post任务到所有线程的一些方法。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>
<span style=color:#204a87;font-weight:700>class</span> <span style=color:#000>InstanceImpl</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>Instance</span> <span style=color:#000;font-weight:700>{</span>
 <span style=color:#204a87;font-weight:700>public</span><span style=color:#ce5c00;font-weight:700>:</span>
	<span style=color:#000;font-weight:700>....</span>
 <span style=color:#204a87;font-weight:700>private</span><span style=color:#ce5c00;font-weight:700>:</span>
  <span style=color:#8f5902;font-style:italic>// post任务到所有注册的线程中
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>runOnAllThreads</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>Event</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>PostCb</span> <span style=color:#000>cb</span><span style=color:#000;font-weight:700>);</span>
  <span style=color:#8f5902;font-style:italic>// post任务到所有注册的线程中，完成后通过main_callback进行通知
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>runOnAllThreads</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>Event</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>PostCb</span> <span style=color:#000>cb</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>Event</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>PostCb</span> <span style=color:#000>main_callback</span><span style=color:#000;font-weight:700>);</span>
  <span style=color:#8f5902;font-style:italic>// 初始化TLS指向对应的数据对象指针
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>setThreadLocal</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>uint32_t</span> <span style=color:#000>index</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>ThreadLocalObjectSharedPtr</span> <span style=color:#000>object</span><span style=color:#000;font-weight:700>);</span>
  <span style=color:#000;font-weight:700>.....</span>
  <span style=color:#8f5902;font-style:italic>// 保存所有注册的线程
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#000>std</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>list</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>std</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>reference_wrapper</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Event</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>Dispatcher</span><span style=color:#ce5c00;font-weight:700>&gt;&gt;</span> <span style=color:#000>registered_threads_</span><span style=color:#000;font-weight:700>;</span>
</code></pre></div><p>​ 因为所有的线程都会注册都<code>InstanceImpl</code>中，所以只需要遍历所有的线程所对应的<code>Dispatcher</code> 对象，调用其post方法将任务投递到对应线程即可，但是如何做到等所有任务执行完成后进行通知呢 ？</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>InstanceImpl</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>runOnAllThreads</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>Event</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>PostCb</span> <span style=color:#000>cb</span><span style=color:#000;font-weight:700>,</span> 
                                   <span style=color:#000>Event</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>PostCb</span> <span style=color:#000>all_threads_complete_cb</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
  <span style=color:#000>ASSERT</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>std</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>this_thread</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>get_id</span><span style=color:#000;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>main_thread_id_</span><span style=color:#000;font-weight:700>);</span>
  <span style=color:#000>ASSERT</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>!</span><span style=color:#000>shutdown_</span><span style=color:#000;font-weight:700>);</span>
  <span style=color:#8f5902;font-style:italic>// 首先在主线程执行任务
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#000>cb</span><span style=color:#000;font-weight:700>();</span>
  <span style=color:#8f5902;font-style:italic>// 利用了shared_ptr自定义析构函数，在析构的时候向主线程post一个完成的通知任务
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#8f5902;font-style:italic>// 这个机制和Bookkeeper的实现机制是一样的。
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#000>std</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>shared_ptr</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Event</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>PostCb</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#000>cb_guard</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>new</span> <span style=color:#000>Event</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>PostCb</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>cb</span><span style=color:#000;font-weight:700>),</span>
                   <span style=color:#000;font-weight:700>[</span><span style=color:#204a87;font-weight:700>this</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>all_threads_complete_cb</span><span style=color:#000;font-weight:700>](</span><span style=color:#000>Event</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>PostCb</span><span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>cb</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
                    <span style=color:#000>main_thread_dispatcher_</span><span style=color:#ce5c00;font-weight:700>-&gt;</span><span style=color:#000>post</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>all_threads_complete_cb</span><span style=color:#000;font-weight:700>);</span>
                      <span style=color:#204a87;font-weight:700>delete</span> <span style=color:#000>cb</span><span style=color:#000;font-weight:700>;</span> <span style=color:#000;font-weight:700>});</span>

  <span style=color:#204a87;font-weight:700>for</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>Event</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>Dispatcher</span><span style=color:#ce5c00;font-weight:700>&amp;</span> <span style=color:#f57900>dispatcher</span> <span style=color:#000;font-weight:700>:</span> <span style=color:#000>registered_threads_</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
    <span style=color:#000>dispatcher</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>post</span><span style=color:#000;font-weight:700>([</span><span style=color:#000>cb_guard</span><span style=color:#000;font-weight:700>]()</span> <span style=color:#ce5c00;font-weight:700>-&gt;</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000;font-weight:700>{</span> <span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>cb_guard</span><span style=color:#000;font-weight:700>)();</span> <span style=color:#000;font-weight:700>});</span>
  <span style=color:#000;font-weight:700>}</span>
<span style=color:#000;font-weight:700>}</span>
</code></pre></div><p>​ 通过上面的代码可以看到，这里仍然利用到了<code>shared_ptr</code>的引用计数机制来实现的。每一个post到其他线程的任务都会导致<code>cb_guard</code>引用计数加1，post任务执行完成后<code>cb_guard</code>引用计数减1，等全部任务完成后，<code>cb_guard</code> 的引用计数就变成0了，这个时候就会执行自定义的删除器，在删除器中就会post一个任务到主线程中，从而实现了任务执行完成的通知回调机制。</p><p>​ 接下来我们来分析下<code>shutdownGlobalThreading</code>，这个函数是用于设置flag来表示正在关闭TLS，必须由主线程在其它worker线程退出之前来调用，调用完成后每一个worker线程还需要调用对应TLS的<code>shutdownThread</code>来清理TLS中的对象，到此为止才完成了全部的TLS清理工作。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>InstanceImpl</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>shutdownGlobalThreading</span><span style=color:#000;font-weight:700>()</span> <span style=color:#000;font-weight:700>{</span>
  <span style=color:#000>ASSERT</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>std</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>this_thread</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>get_id</span><span style=color:#000;font-weight:700>()</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>main_thread_id_</span><span style=color:#000;font-weight:700>);</span>
  <span style=color:#000>ASSERT</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>!</span><span style=color:#000>shutdown_</span><span style=color:#000;font-weight:700>);</span>
  <span style=color:#000>shutdown_</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87>true</span><span style=color:#000;font-weight:700>;</span>
<span style=color:#000;font-weight:700>}</span>
</code></pre></div><p>上面的代码是<code>shutdownGlobalThreading</code>的实现，可以看到仅仅是设置了一个<code>shutdown_</code>的标志。</p><p>​ 最后来分析一下<code>shutdownThread</code>，每一个work线程在退出事都需要调用这个函数，这个函数会将存储的所有线程存储的对象进行清除。每一个worker线程都持有<code>InstanceImpl</code>实例的引用，在析构的时候会调用<code>shutdownThread</code>来释放自己线程的TLS内容，这个函数的实现如下:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>InstanceImpl</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>shutdownThread</span><span style=color:#000;font-weight:700>()</span> <span style=color:#000;font-weight:700>{</span>
  <span style=color:#000>ASSERT</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>shutdown_</span><span style=color:#000;font-weight:700>);</span>
  <span style=color:#204a87;font-weight:700>for</span> <span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>auto</span> <span style=color:#000>it</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>thread_local_data_</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>data_</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>rbegin</span><span style=color:#000;font-weight:700>();</span> 
	   <span style=color:#000>it</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#000>thread_local_data_</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>data_</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>rend</span><span style=color:#000;font-weight:700>();</span> <span style=color:#ce5c00;font-weight:700>++</span><span style=color:#000>it</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
    <span style=color:#000>it</span><span style=color:#ce5c00;font-weight:700>-&gt;</span><span style=color:#000>reset</span><span style=color:#000;font-weight:700>();</span>
  <span style=color:#000;font-weight:700>}</span>
  <span style=color:#000>thread_local_data_</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>data_</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>clear</span><span style=color:#000;font-weight:700>();</span>
<span style=color:#000;font-weight:700>}</span>
</code></pre></div><p>​ 比较奇怪的点在于这里是逆序遍历所有的<code>ThreadLocalObject</code>对象来进行reset的，这是因为一些"持久&rdquo;(活的比较长)的对象如<code>ClusterManagerImpl</code>很早就会创建<code>ThreadLocalObject</code>对象，但是直到shutdown的时候也不析构，而在此基础上依赖<code>ClusterManagerImpl</code>的对象的如<code>GrpcClientImpl</code>等，则是后创建<code>ThreadLocalObject</code>对象，如果<code>ClusterManagerImpl</code>创建的<code>ThreadLocalObject</code>对象先析构，而<code>GrpcClientImpl</code>相关的<code>ThreadLocalObject</code>对象依赖了<code>ClusterManagerImpl</code>相关的TLS内容，那么后析构就会导致未定义的问题。为此这里选择逆序来进行<code>reset</code>，先从一个高层的对象开始，最后才开始对一些基础的对象所关联的<code>ThreadLocalObject</code>进行<code>reset</code>。例如下面这个例子:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>ThreadLocalPool</span> <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>public</span> <span style=color:#000>ThreadLocal</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>ThreadLocalObject</span> <span style=color:#000;font-weight:700>{</span>
	<span style=color:#000;font-weight:700>.....</span>
  <span style=color:#000>InstanceImpl</span><span style=color:#ce5c00;font-weight:700>&amp;</span> <span style=color:#000>parent_</span><span style=color:#000;font-weight:700>;</span>
  <span style=color:#000>Event</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>Dispatcher</span><span style=color:#ce5c00;font-weight:700>&amp;</span> <span style=color:#000>dispatcher_</span><span style=color:#000;font-weight:700>;</span>
  <span style=color:#000>Upstream</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>ThreadLocalCluster</span><span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>cluster_</span><span style=color:#000;font-weight:700>;</span>
	<span style=color:#000;font-weight:700>.....</span>
<span style=color:#000;font-weight:700>};</span>
</code></pre></div><p>​ <code>redis_proxy</code>中定义了一个<code>ThreadLocalPool</code>，这个<code>ThreadLocalPool</code>又依赖较为基础的<code>ThreadLocalCluster</code>(是<code>ThreadLocalClusterManagerImpl</code>的数据成员，也就是<code>ClusterManagerImpl</code>所对应的<code>ThreadLocalObject</code>对象)，如果<code>shutdownThread</code>按照顺序的方式析构的话，那么<code>ThreadLocalPool</code>中使用的<code>ThreadLocalCluster</code>会先被析构，然后才是<code>ThreadLocalPool</code>的析构，而<code>ThreadLocalPool</code>析构的时候又会使用到<code>ThreadLocalCluster</code>，但是<code>ThreadLocalCluster</code>已经析构了，这个时候就会出现野指针的问题了。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#000>ThreadLocalPool</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>ThreadLocalPool</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>InstanceImpl</span><span style=color:#ce5c00;font-weight:700>&amp;</span> <span style=color:#000>parent</span><span style=color:#000;font-weight:700>,</span> 
                                 <span style=color:#000>Event</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>Dispatcher</span><span style=color:#ce5c00;font-weight:700>&amp;</span> <span style=color:#000>dispatcher</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>const</span> 
                                 <span style=color:#000>std</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>string</span><span style=color:#ce5c00;font-weight:700>&amp;</span> <span style=color:#000>cluster_name</span><span style=color:#000;font-weight:700>)</span>
    <span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>parent_</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>parent</span><span style=color:#000;font-weight:700>),</span> <span style=color:#000>dispatcher_</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>dispatcher</span><span style=color:#000;font-weight:700>),</span> 
	<span style=color:#000>cluster_</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>parent_</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>cm_</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>get</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>cluster_name</span><span style=color:#000;font-weight:700>))</span> <span style=color:#000;font-weight:700>{</span>
  <span style=color:#000;font-weight:700>.....</span>
  <span style=color:#000>local_host_set_member_update_cb_handle_</span> <span style=color:#ce5c00;font-weight:700>=</span> 
  <span style=color:#000>cluster_</span><span style=color:#ce5c00;font-weight:700>-&gt;</span><span style=color:#000>prioritySet</span><span style=color:#000;font-weight:700>().</span><span style=color:#000>addMemberUpdateCb</span><span style=color:#000;font-weight:700>(</span>
      <span style=color:#000;font-weight:700>[</span><span style=color:#204a87;font-weight:700>this</span><span style=color:#000;font-weight:700>](</span><span style=color:#204a87;font-weight:700>uint32_t</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>const</span> <span style=color:#000>std</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>vector</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Upstream</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>HostSharedPtr</span><span style=color:#ce5c00;font-weight:700>&gt;&amp;</span><span style=color:#000;font-weight:700>,</span>
             <span style=color:#204a87;font-weight:700>const</span> <span style=color:#000>std</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>vector</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>Upstream</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>HostSharedPtr</span><span style=color:#ce5c00;font-weight:700>&gt;&amp;</span> <span style=color:#000>hosts_removed</span><span style=color:#000;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>-&gt;</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#000;font-weight:700>{</span>
        <span style=color:#000>onHostsRemoved</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>hosts_removed</span><span style=color:#000;font-weight:700>);</span>
      <span style=color:#000;font-weight:700>});</span>
<span style=color:#000;font-weight:700>}</span>

<span style=color:#000>ThreadLocalPool</span><span style=color:#ce5c00;font-weight:700>::~</span><span style=color:#000>ThreadLocalPool</span><span style=color:#000;font-weight:700>()</span> <span style=color:#000;font-weight:700>{</span>
  <span style=color:#8f5902;font-style:italic>// local_host_set_member_update_cb_handle_是ThreadLocalCluster的一部分
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#8f5902;font-style:italic>// ThreadLocalCluster析构会导致local_host_set_member_update_cb_handle_变成野指针
</span><span style=color:#8f5902;font-style:italic></span>  <span style=color:#000>local_host_set_member_update_cb_handle_</span><span style=color:#ce5c00;font-weight:700>-&gt;</span><span style=color:#000>remove</span><span style=color:#000;font-weight:700>();</span>
  <span style=color:#204a87;font-weight:700>while</span> <span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>!</span><span style=color:#000>client_map_</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>empty</span><span style=color:#000;font-weight:700>())</span> <span style=color:#000;font-weight:700>{</span>
    <span style=color:#000>client_map_</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>begin</span><span style=color:#000;font-weight:700>()</span><span style=color:#ce5c00;font-weight:700>-&gt;</span><span style=color:#000>second</span><span style=color:#ce5c00;font-weight:700>-&gt;</span><span style=color:#000>redis_client_</span><span style=color:#ce5c00;font-weight:700>-&gt;</span><span style=color:#000>close</span><span style=color:#000;font-weight:700>();</span>
  <span style=color:#000;font-weight:700>}</span>
<span style=color:#000;font-weight:700>}</span>
</code></pre></div><p>​ 到此为止关于Envoy中的TLS实现就全部分析完毕了。</p><h1 id=小结>小结</h1><p>​ 通过本节的分析相信我们应该足以驾驭Envoy中的<code>ThreadLocal</code>，从其设计可以看出它的一些其巧妙之处，比如抽象出一个<code>Slot</code>和对应的线程存储进行了关联，<code>Slot</code>可以任意传递，因为不包含实际的数据，拷贝的开销很低，只包含了一个索引值，具体关联的线程存储数据是不知道的，避免直接暴露给用户背后的数据。而<code>InstanceImpl</code>对象则管理着所有<code>Slot</code>的分配和移除以及整个<code>ThreadLocal</code>对象的<code>shutdown</code>。还有引入的Bookkeeper机制也甚是巧妙，和<a href=https://envoyproxy-cn.github.io/blog/2020/08/23/envoy%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bdispatcher%E6%9C%BA%E5%88%B6/>Envoy源码分析之Dispatcher机制</a>一文中的<code>DeferredDeletable</code>机制有着异曲同工之妙，通过这个机制可以做到安全的析构<code>SlotImpl</code>对象</p><br><div id=utter-container></div><script src=https://utteranc.es/client.js repo=envoyproxy-cn/comments issue-term=pathname theme=github-light crossorigin=anonymous async></script><ul class="list-unstyled d-flex justify-content-between align-items-center mb-0 pt-5"><li><a class="btn btn-primary disabled"><span class=mr-1>←</span> 上一页</a></li><a href=/blog/2020/08/23/envoy%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bdispatcher%E6%9C%BA%E5%88%B6/ class="btn btn-primary">下一页 <span class=ml-1>→</span></a></li></ul></div></main></div></div><footer class="bg-dark py-5 row d-print-none"><div class="container-fluid mx-sm-5"><div class=row><div class="col-6 col-sm-4 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/envoyproxy-cn/envoyproxy-cn.io><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://envoyproxy.slack.com/archives/C018HMZH37F><i class="fab fa-slack"></i></a></li></ul></div><div class="col-6 col-sm-4 text-right text-xs-center order-sm-3"></div><div class="col-12 col-sm-4 text-center py-2 order-sm-2"><small class=text-white>&copy; 2021 Envoy中文社区 All Rights Reserved <a href=https://beian.miit.gov.cn>粤ICP备15029944号</a></small></div></div></div></footer></div><script src=/js/popper.min.js></script><script src=/js/bootstrap.min.js></script><script src=/js/main.min.664f21bf5eb0c31ebc661e2616e6c63e0448cec6d5636d869957be423c3cb952.js integrity="sha256-Zk8hv16wwx68Zh4mFubGPgRIzsbVY22GmVe+Qjw8uVI=" crossorigin=anonymous></script></body></html>